## v.1.0 一个终于成功的多文件c工程

难得的双休再加上折腾两天的结果，我终于搞懂了Linux--ubuntu上如何编程，以及调试好了Windows上的c环境，还把git 和 github连接上了。
虽然不知道还能不能push上去(已经推上去啦)。  
这份commit会提供一个最简单的多文件模板，但对于小白而言，内容已经足够丰富。xx，我好歹也是电子的半科班出生，怎么这么折腾……  
我相信有很多人即使看完教程也会一脸蒙蔽，但接下来请耐心地顺着我的思路，我会尽量用通俗易懂的方式，让你迈出码农的第一步——我有自信确保这会比你在非科班学校里所学的更加实用。  
对于新手而言，搭建环境并理解整个编译链接过程是至关重要的。
你需要问自己如下问题：

1. 编译是什么
2. 怎么搭建一个编译环境
3. 运用编译器编译单个代码
4. 怎么编译多个文件

请务必牢记这4个问题，接下来我会开始解答。
  
### 1.编译是什么

对于新手而言，只要知道编译需要编译器这一点即可。就像你做饭总得有个加热的玩意，不管是电饭煲还是电磁炉，烧煤气罐，还是烧柴火。  
简单来讲我们平常说的编译，就是把你写的代码通过各种手段，变成目标程序可执行文件的过程。  
编译的流程是这样：  

&emsp;&emsp;1 **预编译(Propressing)**: 这一步是把头文件(.h)和源文件(.c)整合起来。  
&emsp;&emsp;helloWorld.h + helloWorld.c ---> helloWorld.i  
&emsp;&emsp;2 **编译(Compliation)**：这一步会把整合好的文件进行转译，构建出用汇编语言编写的文件  
&emsp;&emsp;helloWorld.i ---> helloWorld.s  
&emsp;&emsp;3 **汇编(Assembly)**: 这一步会把汇编语言写的文件转移并构建出目标文件  
&emsp;&emsp;helloWorld.s ---> helloWorld.o  
&emsp;&emsp;4 **链接(Linking)**: 这一步会把其他文件一起整合，然后构建出可执行文件  
&emsp;&emsp;xxx.so/xxx.a + helloWorld.o ---> helloWorld.out  

可以看到，编译器其实不止干了编译的活，实际上四个活编译器都要干。  
这里对很多小白而言理解起来会比较困难，我建议先往后读，做一个练习后再倒回来，会更有体会。  
总之，记住，你需要有个**编译器**来做这些活。

### 2.搭建编译环境

写完代码总是要调试验证的。  
编程的大体原理是通的，python需要python的解释器，java需要java的环境，c/c++也不例外。  
但是很可惜，很多人都认识不到这一层。据我所知很多非科班甚至该死的科班出生的小伙子些，不少人学c语言就是在课堂里睡大觉。而学校的古董些教书只知道用Visual C++ 6.0，好点的给你用上Dev c++。  
一些比较优秀的人会参加竞赛，玩单片机的可能用下keil，有的则被大佬带着下个巨硬Visual Studio，一键安装后装了啥也不知道。  
这些人写完代码就是一件运行Complie，刷刷刷程序出来了，内部发生了也不知道，看着hello world或者流水灯：“诶，我真牛逼”。  
————反正就是没自己搭个环境。————  

**所以，重点来了！**

1. 在**Windows**环境下，有个编译器名称叫做**gcc**，大名叫做**MingW**，至于现在，只要你不是古董机器，你应该下个x64版本的**MingW64**。

2. 如果你是**Linux**环境， ~~你都用Linxu了还装什么萌新？~~，你不用下载MingW了，但也得装个gcc编译器。

3. 至于mac，我穷，不懂

安装好后，还需要添加环境变量，让电脑知道到哪里去找这个编译器。  

![示例图片](/image/path_for_mingw.png)  

添加环境变量，说白了就是把环境变量里的path 增加一个mingw中bin文件的路径。  
细心且有一定基础的的读者，会发现我还添加了Anacoda3，git等程序到环境变量里。是的，终端里想要执行这些命令，在环境变量中设置这些是必不可少的。
但路径里的bin是啥？bin是binary，二进制的意思，这里面装的都是二进制可执行文件，文本内容里都是0和1。你可以用支持16进制的编辑器或者记事本打开它们。当然，这里用的是安装了插件的Vscode打开的。  
![示例图片](/image/exe_in_bin.png)  
而像dev C++这种软件，就是在下载的时候就在程序内部内置好了编译器，连相关的编译用的指令都给你设置好了。  
完成了安装编译器，设置环境变量等基本操作，如果你在shell/cmd中输入gcc -v 此后能返回gcc的版本，一个编译环境就搭好了。
![示例图片](/image/gcc_version.png)  
当然严谨来讲，c语言的编译器不止gcc这一种，windows上更适配的是msvc，适配linux的还有clang，等。但对新手而言用gcc入门即可。

### 3.运用编译器编译单个代码

好了，现在我们来完成第一步：写一个helloWorld.c文件。  
源代码如下:

    #inculde <stdio.h>
    
    int main(void)
    {
      printf("hello world.\r\n");
      return 0;
    }
你只用把这段文本复制到你的记事本，然后在命名为 helloWorld.c 即可。或者，cykablyat.c，随你喜欢。  

这里很重要，对于新手而言，代码是个神奇的东西，充满了未知与玄妙。  
出于对未知的恐惧，他们能花很长时间在纠结: .c文件我到底设置用默认程序打开。
这里，我告诉你们本质：**所有代码就是文本**。这东西用记事本就能打开，管他哪个编辑器。  
**更深入的来讲，所有计算机上内容，本质上都是1和0。**  
![示例图片](/image/ASCII.png)  
如图所示即为**ASCII码**，你通过键盘敲入的绝大部分字符，会以这种或类似的方式输出给电脑：比如，A就是0100 0001。甚至包括图像，如果你学过矩阵，不妨试想一下怎么用矩阵构造一张图片吧。

是的，所以你能看到码农用VSCode写代码，用Sublime text写代码，用Notepad++写代码，用记事本也能写代码。  
其实，包括你们用的网页，也是代码，也是用文本编辑的。不信你搜个html语法， 用记事本写个玩意，再拿浏览器打开。  
而exe文件，如之前所说的，本质上就是一堆1和0，只不过不同文件意味着不同的编码格式，所以你打开文件会乱码。  
但代码，绝大多数就是文本格式。  

---
下面接着说编译器

而编译器干的活，就是把这些代码，这些文本，转换成二进制文件。  
打开cmd/shell，用cd指令进入你的main.c所在路径，然后输入 gcc main.c 。
如果你的hello world代码写的不烂，gcc会在该路径下，根据操作系统不同生成可执行文件。

1. Linux环境下生成一个a.out文件  
2. Windows环境下会生成一个a.exe文件

到这里，你已经通过cmd/shell，或者专业一点来说，终端，完成了你对代码的编译。接下来你点下你的可执行文件，即可执行。当然，在windows环境下，单纯的点击可能瞬间就结束了，还是推荐通过cmd来执行该文件，或者在程序末尾加入这么一句：

    #inculde <stdio.h>
    #inculde <stdlib.h>
    
    int main(void)
    {
      printf("hello world.\r\n");
      system("pause");
      return 0;
    }

这样，windows上点击你刚生成的exe，会跳出一个cmd窗口，因为有一次等待过程而停止，你就可以看到你编程实现的输出：hello world。

总结一下。你的所有的编程软件，只要需要编译c/c++，都需要这个么个过程： 安装好gcc或者其他编译器，通过不同的方式，根据不同的配置，在终端上执行这么个操作，键入gcc以及配套的其他指令，完成对你的文本代码的吧编译。

### 4.多文件编译

#### 4.1多文件编译--单个目录

在现实的工作和项目中，只靠单个文件来存储我们所有的代码是不现实页不合理的。实际上即使是最简单的helloworld程序，你也会用到c语言标准输入输出库**stdio.h**。  
无奖问答：猜猜标准输入输出库文件在哪？
![示例图片](/image/stdio.h.png)
不同的文件对应着不同功能的代码，有助于我们将代码分层，并模块化。这对我们的开发有着事半功倍的作用。这样我们的工程也更有条例，定位并解决bug起来也更快。
话不多说，让我们来做一个最简单的多文件编译吧。  

仿照之前的写法，我们先写一个helloWorld文件，但这次，我们要编写一个自己的功能函数，并在主文件中引用他的头文件。

首先是我们的功能函数data.c，如你所见我们只让它输出了一句话。

    #include <stdio.h>
    #include "data.h"

    int outputA(void)
    {
        printf("this is outputA.\r\n");
        return 0;
    }  

这是我们头文件，需要命名为data.h。

    #ifndef __DATA_H__
    #define __DATA_H__
    
    #include <stdio.h>

    int outputA(void);
    
    #endif //__DATA_H__

接下来是是我们的helloWorld，main.c文件。

    #include <stdio.h>
    #include <stdlib.h>
    #include "data.h"

    int main(void)
    {
        int ret = 0 ;
        
        printf("main start.\r\n");

        ret = outputA();
        if (ret != 0) {
            printf("outputA failed! (ret=%d)\r\n", ret);
        }
        system("pause");
        return 0;
    }

对于绝对的新手而言，我知道有很多细节你还不太懂，但我们现在的重点在怎么编译上。请耐心往后读。  
在windows环境上，我们只用在文件管理器中文件所在地的地址栏输入cmd即可打开终端。  
而在Linux环境上，shell终端完全可以右键后的目录打开。  
![示例图片](/image/cmd.png)  

然后，鉴于我们的头文件和main.c在同一目录下，我们只用输入如下指令即可。

    gcc data.c main.c -o main

其中 -o 是out的意思，会直接生成可执行文件。其后的是生成文件的名称。点击生成的文件后结果如下。
![示例图片](/image/complie1.png)

至此，恭喜，你的第一次多文件编译圆满完成！

#### 4.2多文件编译--多个目录

下面这中遇到本章的重点了：如何在编译多个目录下的的多个文件？  
一些熟练的老手会说makefile，会说cmake，或者各种各样乱七八糟的辅助软件。当然，新手还是一脸懵逼。  
现在，我们返璞归真，我们用最本质的方式来构建一个工程。

如果你在真正的投入一个项目，相信我，将所有代码放在一个文件夹里是绝对愚蠢的想法。不用说基本库，为实现需求而创建各种各样的庞杂的功能函数，同一目录下仅仅靠a-z的次序进行分类，真是令人沮丧。  
更重要的是，各种文件之间的关系错综复杂，引用与被引用如吃饭喝水般正常。
尤其是，当涉及到需求变更的时候，不管是增加模块还是更改，减少某个模块，盘根错节的文件关系以及各种需要梳理的复杂逻辑，会成为开发者的绝对噩梦。随着项目的推进，以及公司内人员的流动，一些代码就变成了屎山。当然，对于开发者个人来说，你自己的代码写成这样，是一种耻辱。若这是靠兴趣自己动手琢磨出来的成果，自己也为新想法难以实现而苦恼。

下面我们按照以下结构建立我们的工程：

- /src
  - /data
    - data.c
    - data.h
  - main.c

这样的结构还不是很规范，但我们至少把data功能给模块化了，下面我们试着编译它

我们进入src目录下，我们的main函数在这里，接下来我我们输入如下指令：

    gcc ./*.c data/* -I data -o main

![示例图片](/image/complie2.png)

对比之前的指令，这里多了一些参数。  
**`-I`** 是链接的意思，gcc会先从我们指定的地址查找链接的头文件，再回到去查找当前目录，以及环境变量里设置的目录去查找。
**`./*.c`** 是读取当前目录中所有的.c文件。同理后面的 **`data/*.c`**。

这样，从多个目录下编译我们所需要的文件也完成了。可喜可贺。

#### 4.3多文件编译--VScode上编译c语言

尽管上述教程已经用终端做到了c语言多编译，但倘若我们想及时调试我们的程序，一遍又一遍的的在终端中输入这些指令实在是太麻烦了。
VScode中提供了这样的插件，在Microsoft关于VScode的[官方文档]((https://code.visualstudio.com/docs/cpp/introvideos-cpp))里有这样视频教程。

考虑到我们之前大费周章所介绍的，我们肯定要先把编译器与VScode关联起来。
点击你的想要编译运行的文件，再点击VScode菜单栏右上方的三角
![示例图片](/image/run.png)
此时选择 **`运行c/c++文件`** ，系统会自动在文件目录下生成一个tasks.json文件。
当然，你也可以通过ctrl+shift+p键来调出指令蓝，输入 **`Configure Default Build Task`** 来创建tasks.json。

**这个tasks.json文件就是用来构建我们c/c++程序的。它可以创建多个task任务，然后把我们配置好的指令输入给计算机，让它帮助我们调用编译器来编译。**

如下是我们这次用来配置的tasks.json文件中的内容：

    {
    "tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe 生成活动文件",
            "command": "C:\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "-Wall",
                "${fileDirname}\\*.c",
                "${fileDirname}\\data\\*.c",
                "-I",
                "${fileDirname}\\data",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "调试器生成的任务。"
        }
    ],
    "version": "2.0.0"
}

文中所展示的这份tasks.json文件和系统默认生成的tasks.json是不同的的。
重点在于：

1. 其一，使用了**`-I`**指令，把data目录下中的.h文件给链接了进来。
2. 其二，**`-O`** 指令前增加了data目录下的所有.c文件。

如果你仔细观察一下我们所配置的文字，会发现其主要内容与我们之前所用的 **`gcc ./*.c data/* -I data -o main`** 指令大同小异，多出来的只是其他方便调试时配置

是的，你需要先搭建环境变量，指明你所用编译器是哪一个，在什么路径下。此后，你需要指明编译那些文件，以及链接哪些文件。argus中的内容即我们平时使用gcc时所用的参数。

在完成以上配置后，你就可以点击 **`运行c/c++文件`** ，此时VScode就编译出可执行文件，并直接运行。
当然，你也可以用快捷键 ctrl+shift+b 来一件构建，这时不会执行生成的可执行文件。

如果你对task.json中的各个参数感兴趣的话，可以参考如下文字。
这份内容转载自[知乎](https://zhuanlan.zhihu.com/p/92175757)。其中g++是c++常用的编译器。

    // tasks.json
    {
        // https://code.visualstudio.com/docs/editor/tasks
        "version": "2.0.0",
        "tasks": [
            {
                "label": "Build",  // 任务的名字叫Build，注意是大小写区分的，等会在launch中调用这个名字
                "type": "shell",  // 任务执行的是shell命令，也可以是
                "command": "g++", // 命令是g++
                "args": [
                    "'-Wall'",  //生成所有警告信息
                    "'-std=c++17'",  //使用c++17标准编译
                    "'${file}'", //当前文件名
                    "-o", //对象名，不进行编译优化
                    "'${fileBasenameNoExtension}.exe'",  //当前文件名（去掉扩展名）
                ],
              // 所以以上部分，就是在shell中执行（假设文件名为filename.cpp）
              // g++ filename.cpp -o filename.exe
                "group": { 
                    "kind": "build",
                    "isDefault": true   
                    // 任务分组，因为是tasks而不是task，意味着可以连着执行很多任务
                    // 在build组的任务们，可以通过在Command Palette(F1) 输入run build task来运行
                    // 当然，如果任务分组是test，你就可以用run test task来运行 
                },
                "problemMatcher": [
                    "$gcc" // 使用gcc捕获错误
                ],
            }
        ]
    }


另外，需要注意一件事，如果你听说或者习惯于使用**RunCode**插件来运行你的程序，请务必注意：
**tasks.json与RunCode插件无关！！**

#### 4.3.x 补充内容--在VScode上调试c语言
在这里，我们首先需要做的时介绍gdb。
是的，对于绝对小白来讲，调试是什么都得说道说道。
如果你的代码写的很烂，他就会出问题。绝大多数情况是你哪里写错了导致功能没实现，严重点的清空就可能是内存泄漏，segment fault, core dump, 甚至是程序崩溃等问题。
gdb是一种调试器，适合调试由c/c++语言编写的文件，可以支持在程序中打断点，单步以及多步调试等操作。单步调试就是一行一行的执行。gdb源于GNU项目，全称是(the GNU Project debugger)
毫无疑问，这是我们开发程序的利器。
